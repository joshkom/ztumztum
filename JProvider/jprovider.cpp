#include <unstdinttypes.h>
#include <global_common/common.h>
#include "./junkcode/junkcodes.hpp"

#define LOG(...)
#define ERR(...)
//#define LOG(...) __android_log_print(ANDROID_LOG_INFO, "JProvider", __VA_ARGS__)
//#define ERR(...) __android_log_print(ANDROID_LOG_ERROR, "JProvider", __VA_ARGS__)


using namespace std;

class yeuouep {
public:
    int bqawpvuuds;
    double ryxhphfuah;
    double uufxpvi;
    bool opzxqoofzays;

    yeuouep();

    int
    vylurrpusiuzqlrdtx(int ccasgflfjjr, string nzcesysta, bool jaonfizwzrekz, string wdujlbtxhpl,
                       bool mtpcvpwzahe, bool koyoxfhy, bool lfrydcsmakdggzj);

protected:
    bool kolrphdzwdawuks;
    string owpaydwnt;
    double umydrqbnu;

    double
    pqeuthmitf(int gvaoyvpp, bool liktcpgobhm, int olxlyp, string bspswzfofkejjjk, int kcnlmlas,
               bool etmuhzmoiaggc, double bkkdkrxfy, int jgqww);

    int nevlaeyjmrpcqdan(bool ivmiqu, bool qvdpl, int scufepywgsson, double yesnrwfsq,
                         double nbotdlswpvxldmg, bool geneby, string tfskgsu, int cfzkt,
                         bool tstbvjyyraksm);

    void tadkeejcvnvpwidbro(bool pvjwms, double jdfhpspwrscsiks, bool jnnncstye, bool cweaysufs);

private:
    int gzhngpbxbfxsvfb;
    double tazfi;
    string brdwtgwcvjyscw;

    void ahlvcecztgkvtvzqywvaszuyu(bool loolrxudaiqm, double rnxamfbyeu, bool gjssdnit,
                                   double qxpprjfyalg, double nwusxdxga, double foxgfj,
                                   double qvhywyh, int fxkci, int sgxrxz);

    string
    ejkodmoxxxszeurthqagyuj(string vqezxjbkxak, bool hawvawsf, double kkkra, double gobrhkpcncooo,
                            int fstkuvyflhkcmo, string ygcdhjmjzjmyuel, string yhwsbrggv,
                            string oqdnjykyyg);

};


void yeuouep::ahlvcecztgkvtvzqywvaszuyu(bool loolrxudaiqm, double rnxamfbyeu, bool gjssdnit,
                                        double qxpprjfyalg, double nwusxdxga, double foxgfj,
                                        double qvhywyh, int fxkci, int sgxrxz) {
    int hvpkfmipm = 5989;
    double fucftviqesvg = 23501;
    bool vmoomecqbw = false;
    double fhxjymoqgdc = 4162;
    double pbmamhhxwyc = 11229;
    double tzeskwfvvvtsisf = 13344;
    int dawpgww = 3844;
    double styxhj = 23390;
    if (13344 == 13344) {
        int upegxicltm;
        for (upegxicltm = 60; upegxicltm > 0; upegxicltm--) {
            continue;
        }
    }
    if (23501 == 23501) {
        int jaczgoab;
        for (jaczgoab = 40; jaczgoab > 0; jaczgoab--) {
            continue;
        }
    }
    if (false == false) {
        int suj;
        for (suj = 48; suj > 0; suj--) {
            continue;
        }
    }
    if (5989 != 5989) {
        int qgexhcew;
        for (qgexhcew = 48; qgexhcew > 0; qgexhcew--) {
            continue;
        }
    }

}

string yeuouep::ejkodmoxxxszeurthqagyuj(string vqezxjbkxak, bool hawvawsf, double kkkra,
                                        double gobrhkpcncooo, int fstkuvyflhkcmo,
                                        string ygcdhjmjzjmyuel, string yhwsbrggv,
                                        string oqdnjykyyg) {
    int fqzildvztlofrv = 971;
    string qajmdf = "eugzisktccfzceaulfwzpbcqcwtrrvpbgtiwottd";
    string pwqygzcxc = "soojusdriokuhkwrzlckygrlffmezhzmpzj";
    double qtjbt = 3911;
    int hurezugyooilifx = 4065;
    bool ksalmongiu = false;
    int cibiz = 6509;
    string tftbinhsi = "zqpvbwdqtkhflkjbttwiyhlsbsqlycjmprucvirymowwthcqtohndwrbaceywejudufiffpwiulr";
    double qbsly = 51733;
    double dkhrlxhzgjnuz = 1453;
    return string("u");
}

double yeuouep::pqeuthmitf(int gvaoyvpp, bool liktcpgobhm, int olxlyp, string bspswzfofkejjjk,
                           int kcnlmlas, bool etmuhzmoiaggc, double bkkdkrxfy, int jgqww) {
    string fsercapuzhmiksd = "jugggvnbktjhkeaermptpwrnxoanmikesswrqdzud";
    int mdvor = 6735;
    int ectvqddbfanl = 2372;
    bool daoxzyvuq = false;
    double hznphwwom = 12465;
    string zvfge = "ufxrujslyeuhyrrlvobviaerkoglggqtjekkbjxfjrdlnlztqpnylmucmj";
    bool kckiekgpnsc = true;
    double evadkofeffbw = 57785;
    if (string("ufxrujslyeuhyrrlvobviaerkoglggqtjekkbjxfjrdlnlztqpnylmucmj") !=
        string("ufxrujslyeuhyrrlvobviaerkoglggqtjekkbjxfjrdlnlztqpnylmucmj")) {
        int hucoa;
        for (hucoa = 64; hucoa > 0; hucoa--) {
            continue;
        }
    }
    if (true != true) {
        int lhgvared;
        for (lhgvared = 87; lhgvared > 0; lhgvared--) {
            continue;
        }
    }
    if (57785 == 57785) {
        int adumgohgtk;
        for (adumgohgtk = 46; adumgohgtk > 0; adumgohgtk--) {
            continue;
        }
    }
    if (true != true) {
        int sfulmve;
        for (sfulmve = 50; sfulmve > 0; sfulmve--) {
            continue;
        }
    }
    if (string("ufxrujslyeuhyrrlvobviaerkoglggqtjekkbjxfjrdlnlztqpnylmucmj") ==
        string("ufxrujslyeuhyrrlvobviaerkoglggqtjekkbjxfjrdlnlztqpnylmucmj")) {
        int ajapdltp;
        for (ajapdltp = 85; ajapdltp > 0; ajapdltp--) {
            continue;
        }
    }
    return 33978;
}


int yeuouep::nevlaeyjmrpcqdan(bool ivmiqu, bool qvdpl, int scufepywgsson, double yesnrwfsq,
                              double nbotdlswpvxldmg, bool geneby, string tfskgsu, int cfzkt,
                              bool tstbvjyyraksm) {
    double zuxeewuwpmmbu = 35039;
    int zadibbbxvtixh = 1808;
    bool hadqncs = false;
    string uqkmnptt = "prrkgyehrbhtgovpgqyytjhzklebcsvvzwehxik";
    int takdr = 1263;
    double febtzjmlvwj = 5361;
    bool ejosxtwkfr = true;
    bool yceidsuzoaw = true;
    double psulihc = 74080;
    int gkbgy = 4558;
    if (74080 == 74080) {
        int ehbpadhy;
        for (ehbpadhy = 23; ehbpadhy > 0; ehbpadhy--) {
            continue;
        }
    }
    if (false != false) {
        int pabhgmyis;
        for (pabhgmyis = 32; pabhgmyis > 0; pabhgmyis--) {
            continue;
        }
    }
    if (4558 != 4558) {
        int jybdrqv;
        for (jybdrqv = 37; jybdrqv > 0; jybdrqv--) {
            continue;
        }
    }
    if (1808 != 1808) {
        int uoukskqnnk;
        for (uoukskqnnk = 46; uoukskqnnk > 0; uoukskqnnk--) {
            continue;
        }
    }
    return 49072;
}

void
yeuouep::tadkeejcvnvpwidbro(bool pvjwms, double jdfhpspwrscsiks, bool jnnncstye, bool cweaysufs) {
    int zngyeolaaiz = 2383;
    double thyjatszg = 23271;
    int zntgjcfifbo = 2119;
    double gocltqygyxks = 5976;
    bool kpeuhhd = false;
    bool peluxwimpoiymd = false;
    if (5976 == 5976) {
        int pzdw;
        for (pzdw = 20; pzdw > 0; pzdw--) {
            continue;
        }
    }
    if (false == false) {
        int irc;
        for (irc = 81; irc > 0; irc--) {
            continue;
        }
    }
    if (5976 != 5976) {
        int xn;
        for (xn = 8; xn > 0; xn--) {
            continue;
        }
    }
    if (false != false) {
        int oqzq;
        for (oqzq = 36; oqzq > 0; oqzq--) {
            continue;
        }
    }
    if (2383 != 2383) {
        int ysz;
        for (ysz = 36; ysz > 0; ysz--) {
            continue;
        }
    }

}

int yeuouep::vylurrpusiuzqlrdtx(int ccasgflfjjr, string nzcesysta, bool jaonfizwzrekz,
                                string wdujlbtxhpl, bool mtpcvpwzahe, bool koyoxfhy,
                                bool lfrydcsmakdggzj) {
    int smbriaod = 2766;
    double seghgial = 2929;
    string buwxvqboxnp = "nzyuhiolmjtcyydnccxjorwlrpqqtwcnthcrlzmehgiarwrs";
    string dyezfvszoqcmsgr = "xuehoocopcnqrticgmffwfcxcyayervvxizmbzzllihrzrypaftn";
    int szmqtqvlei = 6727;
    bool kickhoowmh = true;
    double kufxnfv = 32809;
    double vyzavrccgkqvqpx = 7985;
    int teqqsebeffrik = 829;
    bool ghzcfnfxn = false;
    if (2766 == 2766) {
        int cmodcho;
        for (cmodcho = 49; cmodcho > 0; cmodcho--) {
            continue;
        }
    }
    if (false == false) {
        int kqsi;
        for (kqsi = 35; kqsi > 0; kqsi--) {
            continue;
        }
    }
    return 76750;
}

yeuouep::yeuouep() {
    this->vylurrpusiuzqlrdtx(1548, string("whkyigfyazwyytestnietqohxlepfyotygrhkyqsrrrljsp"), true,
                             string("jmhosjuxfjsed"), false, true, true);
    this->pqeuthmitf(382, true, 2692,
                     string("wrijygmjppjbklbmddfdvofnshdnjyzxzvshqhpsdmbboumjkvdlrutrjpqjninekockli"),
                     6290, false, 22703, 2974);
    this->nevlaeyjmrpcqdan(true, true, 8651, 4113, 50288, true,
                           string("flddbvilvtwpesqtqopzeqgimyujdefjynlglpubjlbdfyhimdmryzqhrylxtutxtuwhcmvqwrokpi"),
                           12, false);
    this->tadkeejcvnvpwidbro(false, 7181, false, false);
    this->ahlvcecztgkvtvzqywvaszuyu(true, 22715, true, 42964, 22995, 42705, 6047, 885, 283);
    this->ejkodmoxxxszeurthqagyuj(
            string("fcmwrvkugzvurmxaezynznxgrbdafsdnalqyrupxpfaswwehuxqppfbrkuzlvamzas"), false,
            67810, 26653, 5174,
            string("rtwnaulngxdmslfcukocveimaavefqyktaxtgpdthotthhfargmnlzepearqonyqohbmfnobxconjeqgmjdaaia"),
            string("gmqpjtnwrjmmcuatqzfocipfqxadilnqndazakjdafeogzcdjkjhpvyxfmfhfqfx"),
            string("xnsiarzacbqmhdjyqzfspfnmuupcnmeaeneyzjqkgioyyjyyfhfxcdfdusxlsbuwfhwgwnxglmcrheptskgbvdexrvahjlz"));
}

//#include <dlfcn.h>
//
//static const char *utils_get_native_libraries_dir() {
//    static char dir_path[512] = {0};
//
//    void (*dummy)() = []() {};
//    auto get_path = [=]() -> const char * {
//        Dl_info info;
//        if (dladdr((void *) dummy, &info) && info.dli_fname) {
//            strncpy(dir_path, info.dli_fname, sizeof(dir_path) - 1);
//            dir_path[sizeof(dir_path) - 1] = '\0';
//            char *last_slash = strrchr(dir_path, '/');
//            if (last_slash) {
//                *last_slash = '\0';
//            }
//            return dir_path;
//        }
//        return nullptr;
//    };
//
//    // Call the lambda
//    return get_path();
//}
//
//#include <regex>
//
//std::string utils_get_base_apk_install_dir() {
//    LOG("lolo");
//    std::string full_path(utils_get_native_libraries_dir());
//    LOG("FULLPATH: %s", full_path.c_str());
//
//    std::regex pattern(R"((/data/app/.*com\.tale\.royale.*?/))");
//    std::smatch match;
//    if (std::regex_search(full_path, match, pattern)) {
//        return match.str(1);
//    }
//
//    return "";
//}


#include <thread>
#include <chrono>
#include <atomic>
#include <jni.h>

static JavaVM *MetaJavaVM;

#include <queue>

struct ToastRequest {
    std::string html_text;
    bool duration_long;
};
static std::queue<ToastRequest> toastQueue;
static std::mutex toastQueueMutex;
static std::atomic<bool> toastCheckerRunning(false);
static std::thread toastCheckerThread;

static JNIEnv *getEnvAttachIfNeeded(bool &didAttach) {
    didAttach = false;
    JNIEnv *env = nullptr;
    if (MetaJavaVM->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK || env == nullptr) {
        if (MetaJavaVM->AttachCurrentThread(&env, nullptr) != JNI_OK || env == nullptr) {
            LOG("getEnvAttachIfNeeded: Failed to attach thread");
            return nullptr;
        }
        didAttach = true;
    }
    return env;
}

static bool currentThreadHasLooper(JNIEnv *env) {
    jclass LooperClass = env->FindClass("android/os/Looper");
    if (!LooperClass) {
        LOG("currentThreadHasLooper: Failed to find Looper class");
        return false;
    }

    jmethodID myLooperMethod = env->GetStaticMethodID(LooperClass, "myLooper",
                                                      "()Landroid/os/Looper;");
    if (!myLooperMethod) {
        LOG("currentThreadHasLooper: Failed to find myLooper method");
        env->DeleteLocalRef(LooperClass);
        return false;
    }

    jobject looper = env->CallStaticObjectMethod(LooperClass, myLooperMethod);
    bool hasLooper = (looper != nullptr);

    if (looper) {
        env->DeleteLocalRef(looper);
    }
    env->DeleteLocalRef(LooperClass);

    return hasLooper;
}

static jobject getApplicationContext(JNIEnv *env) {
    LOG("getApplicationContext: Entering");

    jclass ActivityThreadClass = env->FindClass("android/app/ActivityThread");
    if (!ActivityThreadClass) {
        LOG("getApplicationContext: Failed to find ActivityThread class");
        return nullptr;
    }
    LOG("getApplicationContext: ActivityThread class found");

    jmethodID currentAppMethod = env->GetStaticMethodID(ActivityThreadClass, "currentApplication",
                                                        "()Landroid/app/Application;");
    if (!currentAppMethod) {
        LOG("getApplicationContext: Failed to find currentApplication method");
        env->DeleteLocalRef(ActivityThreadClass);
        return nullptr;
    }
    LOG("getApplicationContext: currentApplication method ID found");

    jobject context = env->CallStaticObjectMethod(ActivityThreadClass, currentAppMethod);
    if (!context) {
        LOG("getApplicationContext: currentApplication returned null");
    } else {
        LOG("getApplicationContext: context acquired");
    }

    env->DeleteLocalRef(ActivityThreadClass);
    return context;
}

static bool canShowToast(JNIEnv *env) {
    jobject ctx = getApplicationContext(env);
    if (!ctx) {
        LOG("canShowToast: Context not available yet");
        return false;
    }
    env->DeleteLocalRef(ctx);
    return true;
}

void processToast(JNIEnv *env, const ToastRequest &req) {
    LOG("processToast: Starting with text = %s, duration_long = %d", req.html_text.c_str(),
        req.duration_long);

    // Check if current thread has Looper
    if (!currentThreadHasLooper(env)) {
        LOG("processToast: Current thread has no Looper, preparing Looper");
        jclass LooperClass = env->FindClass("android/os/Looper");
        if (LooperClass) {
            jmethodID prepareMethod = env->GetStaticMethodID(LooperClass, "prepare", "()V");
            if (prepareMethod) {
                env->CallStaticVoidMethod(LooperClass, prepareMethod);
                LOG("processToast: Looper prepared");
            } else {
                LOG("processToast: Failed to find Looper.prepare method");
            }
            env->DeleteLocalRef(LooperClass);
        } else {
            LOG("processToast: Failed to find Looper class for prepare");
        }
    } else {
        LOG("processToast: Current thread already has Looper");
    }

    jobject context = getApplicationContext(env);
    if (!context) {
        LOG("processToast: Context is null, skipping");
        return;
    }
    LOG("processToast: Context acquired");

    LOG("processToast: Starting with text = %s, duration_long = %d", req.html_text.c_str(),
        req.duration_long);

    jclass HtmlClass = env->FindClass("android/text/Html");
    if (!HtmlClass) {
        LOG("processToast: Failed to find Html class");
        env->DeleteLocalRef(context);
        return;
    }
    LOG("processToast: Html class found");

    jmethodID fromHtmlMethod = env->GetStaticMethodID(HtmlClass, "fromHtml",
                                                      "(Ljava/lang/String;)Landroid/text/Spanned;");
    if (!fromHtmlMethod) {
        LOG("processToast: Failed to find fromHtml method");
        env->DeleteLocalRef(context);
        env->DeleteLocalRef(HtmlClass);
        return;
    }
    LOG("processToast: fromHtml method ID obtained");

    jstring j_html = env->NewStringUTF(req.html_text.c_str());
    if (!j_html) {
        LOG("processToast: Failed to create jstring for HTML");
        env->DeleteLocalRef(context);
        env->DeleteLocalRef(HtmlClass);
        return;
    }
    LOG("processToast: jstring created");

    jobject spanned = env->CallStaticObjectMethod(HtmlClass, fromHtmlMethod, j_html);
    if (!spanned) {
        LOG("processToast: fromHtml returned null");
        env->DeleteLocalRef(context);
        env->DeleteLocalRef(HtmlClass);
        env->DeleteLocalRef(j_html);
        return;
    }
    LOG("processToast: Spanned result obtained");

    jclass ToastClass = env->FindClass("android/widget/Toast");
    if (!ToastClass) {
        LOG("processToast: Failed to find Toast class");
        env->DeleteLocalRef(context);
        env->DeleteLocalRef(HtmlClass);
        env->DeleteLocalRef(j_html);
        env->DeleteLocalRef(spanned);
        return;
    }
    LOG("processToast: Toast class found");

    jmethodID makeTextMethod = env->GetStaticMethodID(ToastClass, "makeText",
                                                      "(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;");
    if (!makeTextMethod) {
        LOG("processToast: Failed to find makeText method");
        env->DeleteLocalRef(context);
        env->DeleteLocalRef(HtmlClass);
        env->DeleteLocalRef(j_html);
        env->DeleteLocalRef(spanned);
        env->DeleteLocalRef(ToastClass);
        return;
    }
    LOG("processToast: makeText method ID obtained");

    int duration = req.duration_long ? 1 : 0;
    jobject toast = env->CallStaticObjectMethod(ToastClass, makeTextMethod, context, spanned,
                                                duration);
    if (!toast) {
        LOG("processToast: makeText returned null toast");
        env->DeleteLocalRef(context);
        env->DeleteLocalRef(HtmlClass);
        env->DeleteLocalRef(j_html);
        env->DeleteLocalRef(spanned);
        env->DeleteLocalRef(ToastClass);
        return;
    }
    LOG("processToast: Toast object created");

    jmethodID showMethod = env->GetMethodID(ToastClass, "show", "()V");
    if (!showMethod) {
        LOG("processToast: Failed to find show method");
    } else {
        env->CallVoidMethod(toast, showMethod);
        LOG("processToast: Toast shown");
    }

    // Cleanup
    env->DeleteLocalRef(context);
    env->DeleteLocalRef(HtmlClass);
    env->DeleteLocalRef(j_html);
    env->DeleteLocalRef(spanned);
    env->DeleteLocalRef(ToastClass);
    env->DeleteLocalRef(toast);
    LOG("processToast: Finished and cleaned up");
}

void flushToastQueue() {
    bool didAttach = false;
    JNIEnv *env = getEnvAttachIfNeeded(didAttach);
    if (!env) {
        LOG("flushToastQueue: Could not get JNIEnv");
        return;
    }

    if (!canShowToast(env)) {
        LOG("flushToastQueue: Context still not available");
        if (didAttach) MetaJavaVM->DetachCurrentThread();
        return;
    }

    std::lock_guard<std::mutex> lock(toastQueueMutex);
    while (!toastQueue.empty()) {
        const auto &req = toastQueue.front();
        processToast(env, req);
        toastQueue.pop();
    }

    if (didAttach) {
        MetaJavaVM->DetachCurrentThread();
    }
}

void toastCheckerLoop() {
    while (true) {
        std::this_thread::sleep_for(std::chrono::milliseconds(200));

        bool didAttach = false;
        JNIEnv *env = getEnvAttachIfNeeded(didAttach);
        if (!env) {
            LOG("toastCheckerLoop: Could not get JNIEnv, retrying...");
            continue;
        }

        if (canShowToast(env)) {
            LOG("toastCheckerLoop: Context ready, flushing toast queue");
            flushToastQueue();

            if (didAttach) MetaJavaVM->DetachCurrentThread();
            break;  // Stop checking after success
        }

        if (didAttach) MetaJavaVM->DetachCurrentThread();
    }

    toastCheckerRunning = false;
}

void startToastChecker() {
    bool expected = false;
    if (toastCheckerRunning.compare_exchange_strong(expected, true)) {
        toastCheckerThread = std::thread(toastCheckerLoop);
        toastCheckerThread.detach();  // Run in background, no join needed
    }
}

#ifdef __cplusplus
extern "C" {
#endif

// Prevent inlining, mark as used, and force default visibility so the symbol appears in the dynamic symbol table.
__attribute__((noinline))
__attribute__((used))
__attribute__((visibility("default")))
void MakeToastHtmlJni(char *html_text_arg, bool duration_long_arg) {
    LOG("MakeToastHtmlJni: Invoked");

    if (!html_text_arg) {
        LOG("MakeToastHtmlJni: Received null html_text_arg");
        return;
    }

    LOG("MakeToastHtmlJni: Preparing to show toast - Text: \"%s\", Duration: %d", html_text_arg,
        duration_long_arg);

    bool didAttach = false;
    JNIEnv *env = getEnvAttachIfNeeded(didAttach);
    if (!env) {
        LOG("MakeToastHtmlJni: Failed to get JNIEnv, queuing toast and starting checker");
        {
            std::lock_guard<std::mutex> lock(toastQueueMutex);
            toastQueue.push({html_text_arg, duration_long_arg});
            LOG("MakeToastHtmlJni: Toast request queued");
        }
        startToastChecker();
        return;
    }
    LOG("MakeToastHtmlJni: JNIEnv acquired");

    if (!canShowToast(env)) {
        LOG("MakeToastHtmlJni: Context not ready, queuing toast and starting checker");
        {
            std::lock_guard<std::mutex> lock(toastQueueMutex);
            toastQueue.push({html_text_arg, duration_long_arg});
            LOG("MakeToastHtmlJni: Toast request queued (context unavailable)");
        }
        if (didAttach) {
            LOG("MakeToastHtmlJni: Detaching thread (was attached)");
            MetaJavaVM->DetachCurrentThread();
        }
        startToastChecker();
        return;
    }

    LOG("MakeToastHtmlJni: All checks passed, processing toast now");
    processToast(env, {html_text_arg, duration_long_arg});

    if (didAttach) {
        LOG("MakeToastHtmlJni: Detaching thread (was attached)");
        MetaJavaVM->DetachCurrentThread();
    }

    LOG("MakeToastHtmlJni: Finished");
}

#ifdef __cplusplus
} // extern "C"
#endif

#include <stdatomic.h>
#include <pthread.h>
#include <unistd.h>
#include <jni.h>

static _Atomic(JavaVM *) shadow_vm = nullptr;
static JavaVM *gvm = nullptr;

// State codes:
// -1 = waiting
//  0 = shadow received
//  1 = gvm assigned
//  2 = jprovider.vm assigned
//  3 = jprovider task finished.

struct JProvider {
    u64t magic;
    JavaVM *vm;
    JNIEnv *env;
    _Atomic(int) state;
} volatile static __attribute__((used)) jprovider = {
        .magic = 0x9f9904b0f0f00022ULL,
        .vm = nullptr,
        .env = nullptr,
        .state = -1
};

static void *vm_watcher_thread(void *arg) {
    (void) arg;

    junk001();
    jcode::jcode10();

    // wait until shadow_vm != NULL
    while (atomic_load_explicit(&shadow_vm, memory_order_acquire) == NULL) {
        usleep(5 * 1000); // 5 ms
    }

    jcode::jcode03();

    atomic_store_explicit(&jprovider.state, 0, memory_order_release); // shadow received
    junk001();

    gvm = atomic_load_explicit(&shadow_vm, memory_order_acquire);
    jcode::jcode04();
    atomic_store_explicit(&jprovider.state, 1, memory_order_release); // gvm set

    jprovider.vm = gvm;
    jcode::jcode07();
    atomic_store_explicit(&jprovider.state, 2, memory_order_release); // vm assigned

    junk001();
    jcode::jcode03();

    atomic_store_explicit(&jprovider.state, 3, memory_order_release); // vm assigned
    return nullptr;
}

ATTR_CTOR
static void start_vm_watcher() {
    pthread_t tid;
    pthread_create(&tid, nullptr, vm_watcher_thread, nullptr);
    pthread_detach(tid);
}

void provide_vm(JavaVM *vm) {
    atomic_store_explicit(&shadow_vm, vm, memory_order_release);
}

jint JNI_OnLoad(JavaVM *vm, void *reserved) {
    (void) reserved;
    MetaJavaVM = vm;
    jcode::jcode01();
    jcode::jcode03();
    jcode::jcode05();
    jcode::jcode06();
    jcode::jcode07();
    jcode::jcode09();
    jcode::jcode08();

    provide_vm(vm);

    jcode::jcode10();
    junk001();

    return JNI_VERSION_1_6;
}
