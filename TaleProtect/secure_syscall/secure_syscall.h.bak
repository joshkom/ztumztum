#ifndef TALESTARS_V63_322_SECURE_SYSCALL_H
#define TALESTARS_V63_322_SECURE_SYSCALL_H

#include <unstdinttypes.h>
#include <global_common/common.h>

#include <sys/mman.h>
#include <stdarg.h>
#include <pthread.h>
#include <unistd.h>
#include <syscall.h>

#include <unstdinttypes.h>
#include <unstdmemory_compat.h>


//static inline u64t secure_syscall(
//        i32 svc_num_arg,
//        i32 nargs_arg,
//        ...
//);

// ---- prelude_ptr (svc #0 ; ret) ----
static const u8t secure_encrypted_stub[8] = {
        0x77, 0x77, 0xB9, 0x0C, 0x54, 0xE7, 0x00, 0x15
};

static const u8t secure_key[8] = {
        0xA3, 0x77, 0xB9, 0x0D, 0x82, 0xB8, 0x03, 0xD5
};

#ifdef POTATOSHIELD_OVERKILL
typedef struct {
    u8t *prelude_ptr;
    size_t size;
    volatile int *running;
} stub_info_t;

void *stub_self_heal_thread(void *arg) {
    stub_info_t *stub_info_ptr = (stub_info_t *) arg;
    while (*(stub_info_ptr->running)) {
        for (ulong i = 0; i < stub_info_ptr->size; i++)
            stub_info_ptr->prelude_ptr[i] = secure_encrypted_stub[i] ^ secure_key[i];
        usleep(18 * 1000); /* 18ms */
    }
    return NULL;
}
#endif

FORCE_INLINE u64t secure_syscall(i32 svc_num_arg, i32 nargs_arg, ...) {
    if (nargs_arg > 6) {
        return -1;
    }

    u64t args[6] = {0};
    va_list vl;
    va_start(vl, nargs_arg);
    for (int i = 0; i < nargs_arg; i++)
        args[i] = va_arg(vl, u64t);
    va_end(vl);

    u8t *stub_addr = (u8t *) (void *) mmap(NULL, 8,
                                           PROT_READ | PROT_WRITE | PROT_EXEC,
                                           MAP_ANON | MAP_PRIVATE,
                                           -1, 0);
    if (stub_addr == MAP_FAILED) return -1;

    for (ulong i = 0; i < sizeof(secure_encrypted_stub); i++)
        stub_addr[i] = secure_encrypted_stub[i] ^ secure_key[i];

    LOGI("svc_stub:");
    hexdump(stub_addr, 8);

#ifdef POTATOSHIELD_OVERKILL
    volatile int running = 1;
    stub_info_t stub_info = {
            stub_addr,
            sizeof(secure_encrypted_stub),
            &running
    };

    pthread_t tid;
    if (pthread_create(&tid,
                       NULL,
                       stub_self_heal_thread,
                       &stub_info) != 0) {
        unstdmemory_compat_memset(stub_addr, 0, 8);
        munmap(stub_addr, 8);
        return -1;
    }
#endif

    u64t ret;
    asm volatile(
            "mov x0, %1\n"
            "mov x1, %2\n"
            "mov x2, %3\n"
            "mov x3, %4\n"
            "mov x4, %5\n"
            "mov x5, %6\n"

            "mov w9, %w7\n"

            "ldr x11, =0xA5C3F1D7\n"
            "eor x10, x9, x11\n"
            "eor x10, x10, x11\n"

            "ror x10, x10, #19\n"
            "ror x10, x10, #45\n"

            "lsl x10, x10, #7\n"
            "lsr x10, x10, #7\n"

            "ldr x12, =0x37A2B1C4\n"
            "add x10, x10, x12\n"
            "sub x10, x10, x12\n"

            "mov x8, x10\n"

            "blr %8\n"
            "mov %0, x0\n"
            : "=r"(ret)
            :
            "r"(args[0]), "r"(args[1]),
            "r"(args[2]), "r"(args[3]),
            "r"(args[4]), "r"(args[5]),
            "r"(svc_num_arg), "r"(stub_addr)
            : "x0", "x1", "x2", "x3", "x4", "x5", "x8", "x9", "x10", "x11", "x12"
            );

#ifdef POTATOSHIELD_OVERKILL
    running = 0;
    pthread_join(tid, NULL);
#endif

    unstdmemory_compat_memset(stub_addr, 0, 8);
    munmap(stub_addr, 8);

    return ret;
}

#endif //TALESTARS_V63_322_SECURE_SYSCALL_H
