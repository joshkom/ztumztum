#include "code_integrity_trusted_0.h"
#include "TaleProtect/demolisher/rainbow_terminator.h"

pthread_once_t code_integrity_trusted_0_ensure_segment_readable_onetime_init_once = PTHREAD_ONCE_INIT;

void code_integrity_trusted_0_ensure_segment_readable_onetime_init(void) {
    segments_t segs = get_segments(
            (void *) code_integrity_trusted_0_ensure_segment_readable_onetime_init
    );

    sizet page_size = (sizet) sysconfM(_SC_PAGESIZE);
    if (page_size == (sizet) -1) page_size = 4096;

    uptrt start = (uptrt) segs.exec.start;
    uptrt end = start + segs.exec.size - 1;

    void *mstart = (void *) (start & ~(page_size - 1));
    sizet mlen = (sizet) ((end - (uptrt) mstart) + 1);

    if (mlen % page_size) {
        mlen = ((mlen / page_size) + 1) * page_size;
    }

    if (mprotectM(mstart, mlen, PROT_READ | PROT_EXEC) != 0) {
        LOGE("(CodeIntegrity::Trusted0) ensure_exec_segment_readable_once: mprotect failed");
    } else {
        LOGI("(CodeIntegrity::Trusted0) segment %p..%p is now READ|EXEC (one-time)",
             mstart,
             (void *) ((uptrt) mstart + mlen));
    }
}

_Noreturn void *code_integrity_trusted_0_md5_thread(void *arg) {
    hashset_t *hashes = (hashset_t *) arg;

    segments_t segs = get_segments((void *) code_integrity_trusted_0_md5_thread);

    EVP_MD_CTX *ctx = EVP_MD_CTX_new();
    const EVP_MD *md = EVP_md5();
    while (1) {
        u8t md5_out[16];
        unsigned int out_len = 0;

        EVP_DigestInit_ex(ctx, md, NULL);
        EVP_DigestUpdate(ctx, segs.exec.start, segs.exec.size);
        EVP_DigestFinal_ex(ctx, md5_out, &out_len);

        if (unstdmemory_compat_memcmp(md5_out, hashes->md5, 16) != 0) {
            LOGE("[!] (CodeIntegrity::Trusted0) MD5 hash mismatch detected!");
            // todo: uncomment before release
//            demolisher_rainbow_terminator();
        }

        utils_msleep(28);
    }

    EVP_MD_CTX_free(ctx);
}

_Noreturn void *code_integrity_trusted_0_sha256_thread(void *arg) {
    hashset_t *hashes = (hashset_t *) arg;
    segments_t segs = get_segments((void *) code_integrity_trusted_0_sha256_thread);

    EVP_MD_CTX *ctx = EVP_MD_CTX_new();
    const EVP_MD *md = EVP_sha256();

    while (1) {
        u8t sha_out[32];
        unsigned int out_len = 0;

        EVP_DigestInit_ex(ctx, md, NULL);
        EVP_DigestUpdate(ctx, segs.exec.start, segs.exec.size);
        EVP_DigestFinal_ex(ctx, sha_out, &out_len);

        if (unstdmemory_compat_memcmp(sha_out, hashes->sha256, 32) != 0) {
            LOGE("[!] (CodeIntegrity::Trusted0) SHA256 hash mismatch detected!");
            // todo: uncomment before release
//            demolisher_rainbow_terminator();
        }

        utils_msleep(100);
    }

    EVP_MD_CTX_free(ctx);
}


void code_integrity_trusted_0(hashset_t *hashes) {
    pthread_onceM(
            &code_integrity_trusted_0_ensure_segment_readable_onetime_init_once,
            code_integrity_trusted_0_ensure_segment_readable_onetime_init
    );

    pthread_t tid_md5, tid_sha256;
    if (pthread_createM(&tid_md5, NULL,
                        code_integrity_trusted_0_md5_thread, (void *) hashes)) {
        demolisher_smash();
    }

    if (pthread_detachM(tid_md5)) {
        demolisher_smash();
    }

    if (pthread_createM(&tid_sha256, NULL,
                        code_integrity_trusted_0_sha256_thread, (void *) hashes)) {
        demolisher_smash();
    }

    if (pthread_detachM(tid_sha256)) {
        demolisher_smash();

    }
}
